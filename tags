!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
BUFFER_SIZE	src/http.h	22;"	d
CONSUMER_NAME	src/Makefile	/^CONSUMER_NAME=consumer$/;"	m
HASH_MAX_SIZE	src/hash.h	24;"	d
HAVE_MALLOC_SIZE	src/zmalloc.h	42;"	d
HAVE_MALLOC_SIZE	src/zmalloc.h	52;"	d
HAVE_MALLOC_SIZE	src/zmalloc.h	60;"	d
HTTP_POST	src/http.h	24;"	d
INSTALL	src/Makefile	/^INSTALL=install$/;"	m
INSTALL_BIN	src/Makefile	/^INSTALL_BIN=$(PREFIX)\/bin$/;"	m
LOG_ERROR	src/consumer.h	28;"	d
LOG_VERBOSE	src/consumer.h	27;"	d
MAX_LOGMSG_LEN	src/consumer.h	26;"	d
MKC_LOG_BUFFER_SIZE	src/logger.c	26;"	d	file:
MKC_LOG_DEBUG	src/logger.h	25;"	d
MKC_LOG_ERROR	src/logger.h	24;"	d
MKC_LOG_NOTICE	src/logger.h	22;"	d
MKC_LOG_WARNING	src/logger.h	23;"	d
PREFIX	src/Makefile	/^PREFIX?=\/usr\/local\/rdkafka-consumer$/;"	m
PREFIX_SIZE	src/zmalloc.c	48;"	d	file:
PREFIX_SIZE	src/zmalloc.c	51;"	d	file:
PREFIX_SIZE	src/zmalloc.c	53;"	d	file:
SDS_LLSTR_SIZE	src/sds.c	300;"	d	file:
SDS_MAX_PREALLOC	src/sds.h	34;"	d
SERVER_COMMAND_NUM	src/main.c	34;"	d	file:
ZMALLOC_LIB	src/zmalloc.h	39;"	d
ZMALLOC_LIB	src/zmalloc.h	49;"	d
ZMALLOC_LIB	src/zmalloc.h	65;"	d
_HTTP_H_	src/http.h	20;"	d
__CONF_H_	src/config.h	20;"	d
__CONSUMER_H_	src/consumer.h	19;"	d
__HASH_H_	src/hash.h	19;"	d
__LIST_H_	src/list.h	19;"	d
__LOGGER_H_	src/logger.h	20;"	d
__SDS_H	src/sds.h	32;"	d
__ZMALLOC_H	src/zmalloc.h	32;"	d
__anon1::buffer	src/cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon1	file:	access:public
__anon1::length	src/cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon1	file:	access:public
__anon1::offset	src/cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon1	file:	access:public
__anon2::command_len	src/config.h	/^    int command_len;$/;"	m	struct:__anon2	access:public
__anon2::commands	src/config.h	/^    sds *commands;$/;"	m	struct:__anon2	access:public
__anon2::delay	src/config.h	/^    int delay;  \/\/延迟时间$/;"	m	struct:__anon2	access:public
__anon2::method	src/config.h	/^    char *method;$/;"	m	struct:__anon2	access:public
__anon2::name	src/config.h	/^    char *name;$/;"	m	struct:__anon2	access:public
__anon2::retrynum	src/config.h	/^    int retrynum; \/\/ 0 失败一直重试，值到uri的code为200.$/;"	m	struct:__anon2	access:public
__anon2::uri	src/config.h	/^    char *uri;$/;"	m	struct:__anon2	access:public
__anon3::command_no	src/config.h	/^    int command_no; \/\/ 命令号$/;"	m	struct:__anon3	access:public
__anon3::module_conf	src/config.h	/^    module_conf_t **module_conf;$/;"	m	struct:__anon3	access:public
__anon4::data	src/hash.h	/^    list **data;$/;"	m	struct:__anon4	access:public
__anon4::element_num	src/hash.h	/^    int element_num;$/;"	m	struct:__anon4	access:public
__anon4::free	src/hash.h	/^    int free;$/;"	m	struct:__anon4	access:public
__anon4::size	src/hash.h	/^    int size;$/;"	m	struct:__anon4	access:public
__anon5::buffer	src/cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon5	file:	access:public
__anon5::length	src/cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon5	file:	access:public
__anon5::offset	src/cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon5	file:	access:public
__anon6::command_len	src/config.h	/^    int command_len;$/;"	m	struct:__anon6	access:public
__anon6::commands	src/config.h	/^    sds *commands;$/;"	m	struct:__anon6	access:public
__anon6::delay	src/config.h	/^    int delay;  \/\/延迟时间$/;"	m	struct:__anon6	access:public
__anon6::method	src/config.h	/^    char *method;$/;"	m	struct:__anon6	access:public
__anon6::name	src/config.h	/^    char *name;$/;"	m	struct:__anon6	access:public
__anon6::retrynum	src/config.h	/^    int retrynum; \/\/ 0 失败一直重试，值到uri的code为200.$/;"	m	struct:__anon6	access:public
__anon6::uri	src/config.h	/^    char *uri;$/;"	m	struct:__anon6	access:public
__anon7::command_no	src/config.h	/^    int command_no; \/\/ 命令号$/;"	m	struct:__anon7	access:public
__anon7::module_conf	src/config.h	/^    module_conf_t **module_conf;$/;"	m	struct:__anon7	access:public
__anon8::data	src/hash.h	/^    list **data;$/;"	m	struct:__anon8	access:public
__anon8::element_num	src/hash.h	/^    int element_num;$/;"	m	struct:__anon8	access:public
__anon8::free	src/hash.h	/^    int free;$/;"	m	struct:__anon8	access:public
__anon8::size	src/hash.h	/^    int size;$/;"	m	struct:__anon8	access:public
__str	src/zmalloc.h	36;"	d
__xstr	src/zmalloc.h	35;"	d
brokers	src/config.h	/^    sds brokers;$/;"	m	struct:server_conf_t	access:public
buf	src/sds.h	/^    char buf[];$/;"	m	struct:sdshdr	access:public
buffer	src/cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon1	file:	access:public
buffer	src/cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon5	file:	access:public
cJSON	src/cJSON.h	/^typedef struct cJSON {$/;"	s
cJSON	src/cJSON.h	/^} cJSON;$/;"	t	typeref:struct:cJSON
cJSON::child	src/cJSON.h	/^	struct cJSON *child;		\/* An array or object item will have a child pointer pointing to a chain of the items in the array\/object. *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON	access:public
cJSON::next	src/cJSON.h	/^	struct cJSON *next,*prev;	\/* next\/prev allow you to walk array\/object chains. Alternatively, use GetArraySize\/GetArrayItem\/GetObjectItem *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON	access:public
cJSON::prev	src/cJSON.h	/^	struct cJSON *next,*prev;	\/* next\/prev allow you to walk array\/object chains. Alternatively, use GetArraySize\/GetArrayItem\/GetObjectItem *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::	access:public
cJSON::string	src/cJSON.h	/^	char *string;				\/* The item's name string, if this item is the child of, or is in the list of subitems of an object. *\/$/;"	m	struct:cJSON	access:public
cJSON::type	src/cJSON.h	/^	int type;					\/* The type of the item, as above. *\/$/;"	m	struct:cJSON	access:public
cJSON::valuedouble	src/cJSON.h	/^	double valuedouble;			\/* The item's number, if type==cJSON_Number *\/$/;"	m	struct:cJSON	access:public
cJSON::valueint	src/cJSON.h	/^	int valueint;				\/* The item's number, if type==cJSON_Number *\/$/;"	m	struct:cJSON	access:public
cJSON::valuestring	src/cJSON.h	/^	char *valuestring;			\/* The item's string, if type==cJSON_String *\/$/;"	m	struct:cJSON	access:public
cJSON_AddBoolToObject	src/cJSON.h	148;"	d
cJSON_AddFalseToObject	src/cJSON.h	147;"	d
cJSON_AddItemReferenceToArray	src/cJSON.c	/^void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)						{cJSON_AddItemToArray(array,create_reference(item));}$/;"	f	signature:(cJSON *array, cJSON *item)
cJSON_AddItemReferenceToObject	src/cJSON.c	/^void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)	{cJSON_AddItemToObject(object,string,create_reference(item));}$/;"	f	signature:(cJSON *object,const char *string,cJSON *item)
cJSON_AddItemToArray	src/cJSON.c	/^void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}$/;"	f	signature:(cJSON *array, cJSON *item)
cJSON_AddItemToObject	src/cJSON.c	/^void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}$/;"	f	signature:(cJSON *object,const char *string,cJSON *item)
cJSON_AddItemToObjectCS	src/cJSON.c	/^void   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (!(item->type&cJSON_StringIsConst) && item->string) cJSON_free(item->string);item->string=(char*)string;item->type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}$/;"	f	signature:(cJSON *object,const char *string,cJSON *item)
cJSON_AddNullToObject	src/cJSON.h	145;"	d
cJSON_AddNumberToObject	src/cJSON.h	149;"	d
cJSON_AddStringToObject	src/cJSON.h	150;"	d
cJSON_AddTrueToObject	src/cJSON.h	146;"	d
cJSON_Array	src/cJSON.h	37;"	d
cJSON_ArrayForEach	src/cJSON.h	157;"	d
cJSON_CreateArray	src/cJSON.c	/^cJSON *cJSON_CreateArray(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}$/;"	f	signature:(void)
cJSON_CreateBool	src/cJSON.c	/^cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}$/;"	f	signature:(int b)
cJSON_CreateDoubleArray	src/cJSON.c	/^cJSON *cJSON_CreateDoubleArray(const double *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f	signature:(const double *numbers,int count)
cJSON_CreateFalse	src/cJSON.c	/^cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}$/;"	f	signature:(void)
cJSON_CreateFloatArray	src/cJSON.c	/^cJSON *cJSON_CreateFloatArray(const float *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f	signature:(const float *numbers,int count)
cJSON_CreateIntArray	src/cJSON.c	/^cJSON *cJSON_CreateIntArray(const int *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f	signature:(const int *numbers,int count)
cJSON_CreateNull	src/cJSON.c	/^cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}$/;"	f	signature:(void)
cJSON_CreateNumber	src/cJSON.c	/^cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}$/;"	f	signature:(double num)
cJSON_CreateObject	src/cJSON.c	/^cJSON *cJSON_CreateObject(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}$/;"	f	signature:(void)
cJSON_CreateString	src/cJSON.c	/^cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);if(!item->valuestring){cJSON_Delete(item);return 0;}}return item;}$/;"	f	signature:(const char *string)
cJSON_CreateStringArray	src/cJSON.c	/^cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f	signature:(const char **strings,int count)
cJSON_CreateTrue	src/cJSON.c	/^cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}$/;"	f	signature:(void)
cJSON_Delete	src/cJSON.c	/^void cJSON_Delete(cJSON *c)$/;"	f	signature:(cJSON *c)
cJSON_DeleteItemFromArray	src/cJSON.c	/^void   cJSON_DeleteItemFromArray(cJSON *array,int which)			{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}$/;"	f	signature:(cJSON *array,int which)
cJSON_DeleteItemFromObject	src/cJSON.c	/^void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}$/;"	f	signature:(cJSON *object,const char *string)
cJSON_DetachItemFromArray	src/cJSON.c	/^cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)			{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;$/;"	f	signature:(cJSON *array,int which)
cJSON_DetachItemFromObject	src/cJSON.c	/^cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}$/;"	f	signature:(cJSON *object,const char *string)
cJSON_Duplicate	src/cJSON.c	/^cJSON *cJSON_Duplicate(cJSON *item,int recurse)$/;"	f	signature:(cJSON *item,int recurse)
cJSON_False	src/cJSON.h	32;"	d
cJSON_GetArrayItem	src/cJSON.c	/^cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array?array->child:0;while (c && item>0) item--,c=c->next; return c;}$/;"	f	signature:(cJSON *array,int item)
cJSON_GetArraySize	src/cJSON.c	/^int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}$/;"	f	signature:(cJSON *array)
cJSON_GetErrorPtr	src/cJSON.c	/^const char *cJSON_GetErrorPtr(void) {return global_ep;}$/;"	f	signature:(void)
cJSON_GetObjectItem	src/cJSON.c	/^cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object?object->child:0;while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}$/;"	f	signature:(cJSON *object,const char *string)
cJSON_HasObjectItem	src/cJSON.c	/^int cJSON_HasObjectItem(cJSON *object,const char *string)		{return cJSON_GetObjectItem(object,string)?1:0;}$/;"	f	signature:(cJSON *object,const char *string)
cJSON_Hooks	src/cJSON.h	/^typedef struct cJSON_Hooks {$/;"	s
cJSON_Hooks	src/cJSON.h	/^} cJSON_Hooks;$/;"	t	typeref:struct:cJSON_Hooks
cJSON_Hooks::free_fn	src/cJSON.h	/^      void (*free_fn)(void *ptr);$/;"	m	struct:cJSON_Hooks	access:public
cJSON_Hooks::malloc_fn	src/cJSON.h	/^      void *(*malloc_fn)(size_t sz);$/;"	m	struct:cJSON_Hooks	access:public
cJSON_InitHooks	src/cJSON.c	/^void cJSON_InitHooks(cJSON_Hooks* hooks)$/;"	f	signature:(cJSON_Hooks* hooks)
cJSON_InsertItemInArray	src/cJSON.c	/^void   cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) {cJSON_AddItemToArray(array,newitem);return;}$/;"	f	signature:(cJSON *array,int which,cJSON *newitem)
cJSON_IsReference	src/cJSON.h	40;"	d
cJSON_Minify	src/cJSON.c	/^void cJSON_Minify(char *json)$/;"	f	signature:(char *json)
cJSON_NULL	src/cJSON.h	34;"	d
cJSON_New_Item	src/cJSON.c	/^static cJSON *cJSON_New_Item(void)$/;"	f	file:	signature:(void)
cJSON_Number	src/cJSON.h	35;"	d
cJSON_Object	src/cJSON.h	38;"	d
cJSON_Parse	src/cJSON.c	/^cJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}$/;"	f	signature:(const char *value)
cJSON_ParseWithOpts	src/cJSON.c	/^cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)$/;"	f	signature:(const char *value,const char **return_parse_end,int require_null_terminated)
cJSON_Print	src/cJSON.c	/^char *cJSON_Print(cJSON *item)				{return print_value(item,0,1,0);}$/;"	f	signature:(cJSON *item)
cJSON_PrintBuffered	src/cJSON.c	/^char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt)$/;"	f	signature:(cJSON *item,int prebuffer,int fmt)
cJSON_PrintUnformatted	src/cJSON.c	/^char *cJSON_PrintUnformatted(cJSON *item)	{return print_value(item,0,0,0);}$/;"	f	signature:(cJSON *item)
cJSON_ReplaceItemInArray	src/cJSON.c	/^void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;$/;"	f	signature:(cJSON *array,int which,cJSON *newitem)
cJSON_ReplaceItemInObject	src/cJSON.c	/^void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}$/;"	f	signature:(cJSON *object,const char *string,cJSON *newitem)
cJSON_SetIntValue	src/cJSON.h	153;"	d
cJSON_SetNumberValue	src/cJSON.h	154;"	d
cJSON_String	src/cJSON.h	36;"	d
cJSON_StringIsConst	src/cJSON.h	41;"	d
cJSON_True	src/cJSON.h	33;"	d
cJSON__h	src/cJSON.h	24;"	d
cJSON_free	src/cJSON.c	/^static void (*cJSON_free)(void *ptr) = free;$/;"	v	file:
cJSON_malloc	src/cJSON.c	/^static void *(*cJSON_malloc)(size_t sz) = malloc;$/;"	v	file:
cJSON_strcasecmp	src/cJSON.c	/^static int cJSON_strcasecmp(const char *s1,const char *s2)$/;"	f	file:	signature:(const char *s1,const char *s2)
cJSON_strdup	src/cJSON.c	/^static char* cJSON_strdup(const char* str)$/;"	f	file:	signature:(const char* str)
calloc	src/zmalloc.c	60;"	d	file:
calloc	src/zmalloc.c	65;"	d	file:
child	src/cJSON.h	/^	struct cJSON *child;		\/* An array or object item will have a child pointer pointing to a chain of the items in the array\/object. *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON	access:public
cjson	src/cJSON.h	/^typedef struct cJSON cjson;$/;"	t	typeref:struct:cJSON
cjson_create_string	src/cJSON.h	49;"	d
cjson_delete	src/cJSON.h	46;"	d
cjson_get_item	src/cJSON.h	44;"	d
cjson_parse	src/cJSON.h	43;"	d
cjson_print	src/cJSON.h	47;"	d
command_len	src/config.h	/^    int command_len;$/;"	m	struct:__anon2	access:public
command_len	src/config.h	/^    int command_len;$/;"	m	struct:__anon6	access:public
command_no	src/config.h	/^    int command_no; \/\/ 命令号$/;"	m	struct:__anon3	access:public
command_no	src/config.h	/^    int command_no; \/\/ 命令号$/;"	m	struct:__anon7	access:public
commands	src/config.h	/^    list *commands;$/;"	m	struct:server_conf_t	access:public
commands	src/config.h	/^    sds *commands;$/;"	m	struct:__anon2	access:public
commands	src/config.h	/^    sds *commands;$/;"	m	struct:__anon6	access:public
conffile	src/config.h	/^    char *conffile;$/;"	m	struct:server_conf_t	access:public
confpath	src/config.h	/^    char *confpath;$/;"	m	struct:server_conf_t	access:public
create_reference	src/cJSON.c	/^static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}$/;"	f	file:	signature:(cJSON *item)
daemon	src/config.h	/^    int daemon;$/;"	m	struct:server_conf_t	access:public
daemonize	src/config.h	/^    int daemonize;$/;"	m	struct:server_conf_t	access:public
data	src/hash.h	/^    list **data;$/;"	m	struct:__anon4	access:public
data	src/hash.h	/^    list **data;$/;"	m	struct:__anon8	access:public
debug	src/config.h	/^    int debug;$/;"	m	struct:server_conf_t	access:public
delay	src/config.h	/^    int delay;  \/\/延迟时间$/;"	m	struct:__anon2	access:public
delay	src/config.h	/^    int delay;  \/\/延迟时间$/;"	m	struct:__anon6	access:public
domain	src/config.h	/^    char *domain;$/;"	m	struct:server_conf_t	access:public
element_num	src/hash.h	/^    int element_num;$/;"	m	struct:__anon4	access:public
element_num	src/hash.h	/^    int element_num;$/;"	m	struct:__anon8	access:public
ensure	src/cJSON.c	/^static char* ensure(printbuffer *p,int needed)$/;"	f	file:	signature:(printbuffer *p,int needed)
firstByteMark	src/cJSON.c	/^static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };$/;"	v	file:
free	src/hash.h	/^    int free;$/;"	m	struct:__anon4	access:public
free	src/hash.h	/^    int free;$/;"	m	struct:__anon8	access:public
free	src/list.h	/^    void (*free)(void *ptr);$/;"	m	struct:list	access:public
free	src/sds.h	/^    unsigned int free;$/;"	m	struct:sdshdr	access:public
free	src/zmalloc.c	62;"	d	file:
free	src/zmalloc.c	67;"	d	file:
free_fn	src/cJSON.h	/^      void (*free_fn)(void *ptr);$/;"	m	struct:cJSON_Hooks	access:public
global_ep	src/cJSON.c	/^static const char *global_ep;$/;"	v	file:
group	src/config.h	/^    char *group;$/;"	m	struct:server_conf_t	access:public
hash_add	src/hash.c	/^hash_table *hash_add(hash_table *table,char *key, void *data,void (*list_handler)(void *ptr)){$/;"	f	signature:(hash_table *table,char *key, void *data,void (*list_handler)(void *ptr))
hash_dump	src/hash.c	/^void hash_dump(hash_table *table){$/;"	f	signature:(hash_table *table)
hash_find	src/hash.c	/^list *hash_find(hash_table *table,char *key,int key_len){$/;"	f	signature:(hash_table *table,char *key,int key_len)
hash_free	src/hash.c	/^void hash_free(hash_table *table){$/;"	f	signature:(hash_table *table)
hash_index	src/hash.c	/^int hash_index(const char *key){$/;"	f	signature:(const char *key)
hash_init	src/hash.c	/^hash_table *hash_init(size_t size){$/;"	f	signature:(size_t size)
hash_table	src/hash.h	/^}hash_table;$/;"	t	typeref:struct:__anon4
hash_table	src/hash.h	/^}hash_table;$/;"	t	typeref:struct:__anon8
hashpjw	src/hash.c	/^unsigned long hashpjw(char *key, unsigned int key_len)$/;"	f	signature:(char *key, unsigned int key_len)
head	src/list.h	/^    list_node *head;$/;"	m	struct:list	access:public
hex_digit_to_int	src/sds.c	/^int hex_digit_to_int(char c) {$/;"	f	signature:(char c)
http_client_closed	src/http.c	/^void http_client_closed(int socket_fd){$/;"	f	signature:(int socket_fd)
http_client_create	src/http.c	/^int http_client_create(const char *host,int port){$/;"	f	signature:(const char *host,int port)
http_client_parse_file	src/http.c	/^static int http_client_parse_file(const char *url,char *file,char *host){$/;"	f	file:	signature:(const char *url,char *file,char *host)
http_client_parse_result	src/http.c	/^static http_response_t *http_client_parse_result(const char *result){$/;"	f	file:	signature:(const char *result)
http_client_post	src/http.c	/^http_response_t *http_client_post(char *url,const char *header,char *post_data, int post_len){$/;"	f	signature:(char *url,const char *header,char *post_data, int post_len)
http_client_recv	src/http.c	/^static int http_client_recv(int socket_fd, char *buff){$/;"	f	file:	signature:(int socket_fd, char *buff)
http_client_send	src/http.c	/^static int http_client_send(int socket_fd, char *data, int size){$/;"	f	file:	signature:(int socket_fd, char *data, int size)
http_code	src/http.h	/^    int http_code;$/;"	m	struct:http_response_t	access:public
http_response_t	src/http.h	/^typedef struct http_response_t {$/;"	s
http_response_t	src/http.h	/^}http_response_t;$/;"	t	typeref:struct:http_response_t
http_response_t::http_code	src/http.h	/^    int http_code;$/;"	m	struct:http_response_t	access:public
init_server_conf	src/main.c	/^static void init_server_conf(){$/;"	f	file:
is_hex_digit	src/sds.c	/^int is_hex_digit(char c) {$/;"	f	signature:(char c)
key	src/list.h	/^    char *key;$/;"	m	struct:list_node	access:public
key	src/test.c	/^    int key;$/;"	m	struct:list	file:	access:public
len	src/list.h	/^    size_t len;$/;"	m	struct:list	access:public
len	src/sds.h	/^    unsigned int len;$/;"	m	struct:sdshdr	access:public
length	src/cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon1	file:	access:public
length	src/cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon5	file:	access:public
list	src/list.h	/^typedef struct list{$/;"	s
list	src/list.h	/^}list;$/;"	t	typeref:struct:list
list	src/test.c	/^typedef struct list{$/;"	s	file:
list	src/test.c	/^}list;$/;"	t	typeref:struct:list	file:
list::free	src/list.h	/^    void (*free)(void *ptr);$/;"	m	struct:list	access:public
list::head	src/list.h	/^    list_node *head;$/;"	m	struct:list	access:public
list::key	src/test.c	/^    int key;$/;"	m	struct:list	file:	access:public
list::len	src/list.h	/^    size_t len;$/;"	m	struct:list	access:public
list::tail	src/list.h	/^    list_node *tail;$/;"	m	struct:list	access:public
list_add_node_head	src/list.c	/^list *list_add_node_head(list *list,char *key,void *value){$/;"	f	signature:(list *list,char *key,void *value)
list_add_node_tail	src/list.c	/^list *list_add_node_tail(list *list,char *key,void *value){$/;"	f	signature:(list *list,char *key,void *value)
list_create	src/list.c	/^list *list_create(){$/;"	f
list_deep	src/list.c	/^void list_deep(list *list,list_deep_callback deep_call){$/;"	f	signature:(list *list,list_deep_callback deep_call)
list_deep_callback	src/list.h	/^typedef void (*list_deep_callback) (void *node);$/;"	t
list_dump	src/list.c	/^void list_dump(list *list){$/;"	f	signature:(list *list)
list_find_node	src/list.c	/^list_node *list_find_node(list *list,char *key){$/;"	f	signature:(list *list,char *key)
list_free_handler	src/list.h	/^typedef void (*list_free_handler) (void *ptr);$/;"	t
list_node	src/list.h	/^typedef struct list_node{$/;"	s
list_node	src/list.h	/^}list_node;$/;"	t	typeref:struct:list_node
list_node::key	src/list.h	/^    char *key;$/;"	m	struct:list_node	access:public
list_node::next	src/list.h	/^    struct list_node *next;$/;"	m	struct:list_node	typeref:struct:list_node::list_node	access:public
list_node::prev	src/list.h	/^    struct list_node *prev;$/;"	m	struct:list_node	typeref:struct:list_node::list_node	access:public
list_node::value	src/list.h	/^    void *value;$/;"	m	struct:list_node	access:public
list_release	src/list.c	/^void list_release(list *list){$/;"	f	signature:(list *list)
log_path	src/config.h	/^    char *log_path;$/;"	m	struct:server_conf_t	access:public
logfile	src/config.h	/^    char *logfile;$/;"	m	struct:server_conf_t	access:public
logfp	src/config.h	/^    FILE *logfp;$/;"	m	struct:server_conf_t	access:public
logger	src/main.c	/^static void logger(const rd_kafka_t *rk,int level, const char *fac, const char *buf){$/;"	f	file:	signature:(const rd_kafka_t *rk,int level, const char *fac, const char *buf)
loglevel	src/config.h	/^    int loglevel;$/;"	m	struct:server_conf_t	access:public
main	src/main.c	/^int main(int argc, char **argv){$/;"	f	signature:(int argc, char **argv)
main	src/sds.c	/^int main(void) {$/;"	f	signature:(void)
main	src/test.c	/^int main(int argc, char **argv){$/;"	f	signature:(int argc, char **argv)
malloc	src/zmalloc.c	59;"	d	file:
malloc	src/zmalloc.c	64;"	d	file:
malloc_fn	src/cJSON.h	/^      void *(*malloc_fn)(size_t sz);$/;"	m	struct:cJSON_Hooks	access:public
method	src/config.h	/^    char *method;$/;"	m	struct:__anon2	access:public
method	src/config.h	/^    char *method;$/;"	m	struct:__anon6	access:public
mkc_write_log	src/logger.c	/^int mkc_write_log(int log_level, const char *format,...){$/;"	f	signature:(int log_level, const char *format,...)
mmqLog	src/consumer.c	/^void mmqLog(int level,const char *fmt,...){$/;"	f	signature:(int level,const char *fmt,...)
mmqLogRaw	src/consumer.c	/^void mmqLogRaw(int level,const char *msg){$/;"	f	signature:(int level,const char *msg)
mode	src/config.h	/^    char mode;$/;"	m	struct:server_conf_t	access:public
module_cmd_t	src/config.h	/^}module_cmd_t ;$/;"	t	typeref:struct:__anon3
module_cmd_t	src/config.h	/^}module_cmd_t ;$/;"	t	typeref:struct:__anon7
module_conf	src/config.h	/^    module_conf_t **module_conf;$/;"	m	struct:__anon3	access:public
module_conf	src/config.h	/^    module_conf_t **module_conf;$/;"	m	struct:__anon7	access:public
module_conf_free	src/config.c	/^void module_conf_free(void *module_conf){$/;"	f	signature:(void *module_conf)
module_conf_t	src/config.h	/^}module_conf_t ;$/;"	t	typeref:struct:__anon2
module_conf_t	src/config.h	/^}module_conf_t ;$/;"	t	typeref:struct:__anon6
module_deep_process	src/main.c	/^static void module_deep_process(void *node){$/;"	f	file:	signature:(void *node)
modules	src/config.h	/^    hash_table *modules;$/;"	m	struct:server_conf_t	access:public
msg_consume	src/main.c	/^static int msg_consume(rd_kafka_message_t *rkmessage ,void *opaque){$/;"	f	file:	signature:(rd_kafka_message_t *rkmessage ,void *opaque)
name	src/config.h	/^    char *name;$/;"	m	struct:__anon2	access:public
name	src/config.h	/^    char *name;$/;"	m	struct:__anon6	access:public
next	src/cJSON.h	/^	struct cJSON *next,*prev;	\/* next\/prev allow you to walk array\/object chains. Alternatively, use GetArraySize\/GetArrayItem\/GetObjectItem *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON	access:public
next	src/list.h	/^    struct list_node *next;$/;"	m	struct:list_node	typeref:struct:list_node::list_node	access:public
offset	src/cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon1	file:	access:public
offset	src/cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon5	file:	access:public
parse_array	src/cJSON.c	/^static const char *parse_array(cJSON *item,const char *value,const char **ep)$/;"	f	file:	signature:(cJSON *item,const char *value,const char **ep)
parse_hex4	src/cJSON.c	/^static unsigned parse_hex4(const char *str)$/;"	f	file:	signature:(const char *str)
parse_module_conf	src/config.c	/^module_conf_t *parse_module_conf(const char *filename){$/;"	f	signature:(const char *filename)
parse_number	src/cJSON.c	/^static const char *parse_number(cJSON *item,const char *num)$/;"	f	file:	signature:(cJSON *item,const char *num)
parse_object	src/cJSON.c	/^static const char *parse_object(cJSON *item,const char *value,const char **ep)$/;"	f	file:	signature:(cJSON *item,const char *value,const char **ep)
parse_server_conf	src/config.c	/^int parse_server_conf(char *file_name){$/;"	f	signature:(char *file_name)
parse_string	src/cJSON.c	/^static const char *parse_string(cJSON *item,const char *str,const char **ep)$/;"	f	file:	signature:(cJSON *item,const char *str,const char **ep)
parse_value	src/cJSON.c	/^static const char *parse_value(cJSON *item,const char *value,const char **ep)$/;"	f	file:	signature:(cJSON *item,const char *value,const char **ep)
pidfile	src/config.h	/^    char *pidfile;$/;"	m	struct:server_conf_t	access:public
pipe_fd	src/config.h	/^    int pipe_fd[2];$/;"	m	struct:server_conf_t	access:public
port	src/config.h	/^    char *port;$/;"	m	struct:server_conf_t	access:public
pow2gt	src/cJSON.c	/^static int pow2gt (int x)	{	--x;	x|=x>>1;	x|=x>>2;	x|=x>>4;	x|=x>>8;	x|=x>>16;	return x+1;	}$/;"	f	file:	signature:(int x)
prev	src/cJSON.h	/^	struct cJSON *next,*prev;	\/* next\/prev allow you to walk array\/object chains. Alternatively, use GetArraySize\/GetArrayItem\/GetObjectItem *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::	access:public
prev	src/list.h	/^    struct list_node *prev;$/;"	m	struct:list_node	typeref:struct:list_node::list_node	access:public
print_array	src/cJSON.c	/^static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p)$/;"	f	file:	signature:(cJSON *item,int depth,int fmt,printbuffer *p)
print_number	src/cJSON.c	/^static char *print_number(cJSON *item,printbuffer *p)$/;"	f	file:	signature:(cJSON *item,printbuffer *p)
print_object	src/cJSON.c	/^static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p)$/;"	f	file:	signature:(cJSON *item,int depth,int fmt,printbuffer *p)
print_partition_list	src/main.c	/^static void print_partition_list (FILE *fp,$/;"	f	file:	signature:(FILE *fp, const rd_kafka_topic_partition_list_t *partitions)
print_string	src/cJSON.c	/^static char *print_string(cJSON *item,printbuffer *p)	{return print_string_ptr(item->valuestring,p);}$/;"	f	file:	signature:(cJSON *item,printbuffer *p)
print_string_ptr	src/cJSON.c	/^static char *print_string_ptr(const char *str,printbuffer *p)$/;"	f	file:	signature:(const char *str,printbuffer *p)
print_value	src/cJSON.c	/^static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p)$/;"	f	file:	signature:(cJSON *item,int depth,int fmt,printbuffer *p)
printbuffer	src/cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	t	typeref:struct:__anon1	file:
printbuffer	src/cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	t	typeref:struct:__anon5	file:
process_num	src/config.h	/^    int process_num;$/;"	m	struct:server_conf_t	access:public
process_running	src/main.c	/^static int process_running(int argc, char **argv){$/;"	f	file:	signature:(int argc, char **argv)
realloc	src/zmalloc.c	61;"	d	file:
realloc	src/zmalloc.c	66;"	d	file:
rebalance_cb	src/main.c	/^static void rebalance_cb(rd_kafka_t *rk,rd_kafka_resp_err_t err,rd_kafka_topic_partition_list_t *partitions,void *opaque){$/;"	f	file:	signature:(rd_kafka_t *rk,rd_kafka_resp_err_t err,rd_kafka_topic_partition_list_t *partitions,void *opaque)
retrynum	src/config.h	/^    int retrynum; \/\/ 0 失败一直重试，值到uri的code为200.$/;"	m	struct:__anon2	access:public
retrynum	src/config.h	/^    int retrynum; \/\/ 0 失败一直重试，值到uri的code为200.$/;"	m	struct:__anon6	access:public
rk	src/main.c	/^static rd_kafka_t * rk;$/;"	v	file:
run	src/main.c	/^static int run = 1;$/;"	v	file:
sds	src/sds.h	/^typedef char *sds;$/;"	t
sdsAllocSize	src/sds.c	/^size_t sdsAllocSize(sds s) {$/;"	f	signature:(sds s)
sdsIncrLen	src/sds.c	/^void sdsIncrLen(sds s, int incr) {$/;"	f	signature:(sds s, int incr)
sdsMakeRoomFor	src/sds.c	/^sds sdsMakeRoomFor(sds s, size_t addlen) {$/;"	f	signature:(sds s, size_t addlen)
sdsRemoveFreeSpace	src/sds.c	/^sds sdsRemoveFreeSpace(sds s) {$/;"	f	signature:(sds s)
sdsavail	src/sds.h	/^static inline size_t sdsavail(const sds s) {$/;"	f	signature:(const sds s)
sdscat	src/sds.c	/^sds sdscat(sds s, const char *t) {$/;"	f	signature:(sds s, const char *t)
sdscatfmt	src/sds.c	/^sds sdscatfmt(sds s, char const *fmt, ...) {$/;"	f	signature:(sds s, char const *fmt, ...)
sdscatlen	src/sds.c	/^sds sdscatlen(sds s, const void *t, size_t len) {$/;"	f	signature:(sds s, const void *t, size_t len)
sdscatprintf	src/sds.c	/^sds sdscatprintf(sds s, const char *fmt, ...) {$/;"	f	signature:(sds s, const char *fmt, ...)
sdscatrepr	src/sds.c	/^sds sdscatrepr(sds s, const char *p, size_t len) {$/;"	f	signature:(sds s, const char *p, size_t len)
sdscatsds	src/sds.c	/^sds sdscatsds(sds s, const sds t) {$/;"	f	signature:(sds s, const sds t)
sdscatvprintf	src/sds.c	/^sds sdscatvprintf(sds s, const char *fmt, va_list ap) {$/;"	f	signature:(sds s, const char *fmt, va_list ap)
sdsclear	src/sds.c	/^void sdsclear(sds s) {$/;"	f	signature:(sds s)
sdscmp	src/sds.c	/^int sdscmp(const sds s1, const sds s2) {$/;"	f	signature:(const sds s1, const sds s2)
sdscpy	src/sds.c	/^sds sdscpy(sds s, const char *t) {$/;"	f	signature:(sds s, const char *t)
sdscpylen	src/sds.c	/^sds sdscpylen(sds s, const char *t, size_t len) {$/;"	f	signature:(sds s, const char *t, size_t len)
sdsdup	src/sds.c	/^sds sdsdup(const sds s) {$/;"	f	signature:(const sds s)
sdsempty	src/sds.c	/^sds sdsempty(void) {$/;"	f	signature:(void)
sdsfree	src/sds.c	/^void sdsfree(sds s) {$/;"	f	signature:(sds s)
sdsfreesplitres	src/sds.c	/^void sdsfreesplitres(sds *tokens, int count) {$/;"	f	signature:(sds *tokens, int count)
sdsfromlonglong	src/sds.c	/^sds sdsfromlonglong(long long value) {$/;"	f	signature:(long long value)
sdsgrowzero	src/sds.c	/^sds sdsgrowzero(sds s, size_t len) {$/;"	f	signature:(sds s, size_t len)
sdshdr	src/sds.h	/^struct sdshdr {$/;"	s
sdshdr::buf	src/sds.h	/^    char buf[];$/;"	m	struct:sdshdr	access:public
sdshdr::free	src/sds.h	/^    unsigned int free;$/;"	m	struct:sdshdr	access:public
sdshdr::len	src/sds.h	/^    unsigned int len;$/;"	m	struct:sdshdr	access:public
sdsjoin	src/sds.c	/^sds sdsjoin(char **argv, int argc, char *sep) {$/;"	f	signature:(char **argv, int argc, char *sep)
sdslen	src/sds.h	/^static inline size_t sdslen(const sds s) {$/;"	f	signature:(const sds s)
sdsll2str	src/sds.c	/^int sdsll2str(char *s, long long value) {$/;"	f	signature:(char *s, long long value)
sdsmapchars	src/sds.c	/^sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {$/;"	f	signature:(sds s, const char *from, const char *to, size_t setlen)
sdsnew	src/sds.c	/^sds sdsnew(const char *init) {$/;"	f	signature:(const char *init)
sdsnewlen	src/sds.c	/^sds sdsnewlen(const void *init, size_t initlen) {$/;"	f	signature:(const void *init, size_t initlen)
sdsrange	src/sds.c	/^void sdsrange(sds s, int start, int end) {$/;"	f	signature:(sds s, int start, int end)
sdssplitargs	src/sds.c	/^sds *sdssplitargs(const char *line, int *argc) {$/;"	f	signature:(const char *line, int *argc)
sdssplitlen	src/sds.c	/^sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count) {$/;"	f	signature:(const char *s, int len, const char *sep, int seplen, int *count)
sdstolower	src/sds.c	/^void sdstolower(sds s) {$/;"	f	signature:(sds s)
sdstoupper	src/sds.c	/^void sdstoupper(sds s) {$/;"	f	signature:(sds s)
sdstrim	src/sds.c	/^sds sdstrim(sds s, const char *cset) {$/;"	f	signature:(sds s, const char *cset)
sdsull2str	src/sds.c	/^int sdsull2str(char *s, unsigned long long v) {$/;"	f	signature:(char *s, unsigned long long v)
sdsupdatelen	src/sds.c	/^void sdsupdatelen(sds s) {$/;"	f	signature:(sds s)
server_conf_t	src/config.h	/^typedef struct server_conf_t {$/;"	s
server_conf_t	src/config.h	/^}server_conf_t ;$/;"	t	typeref:struct:server_conf_t
server_conf_t::brokers	src/config.h	/^    sds brokers;$/;"	m	struct:server_conf_t	access:public
server_conf_t::commands	src/config.h	/^    list *commands;$/;"	m	struct:server_conf_t	access:public
server_conf_t::conffile	src/config.h	/^    char *conffile;$/;"	m	struct:server_conf_t	access:public
server_conf_t::confpath	src/config.h	/^    char *confpath;$/;"	m	struct:server_conf_t	access:public
server_conf_t::daemon	src/config.h	/^    int daemon;$/;"	m	struct:server_conf_t	access:public
server_conf_t::daemonize	src/config.h	/^    int daemonize;$/;"	m	struct:server_conf_t	access:public
server_conf_t::debug	src/config.h	/^    int debug;$/;"	m	struct:server_conf_t	access:public
server_conf_t::domain	src/config.h	/^    char *domain;$/;"	m	struct:server_conf_t	access:public
server_conf_t::group	src/config.h	/^    char *group;$/;"	m	struct:server_conf_t	access:public
server_conf_t::log_path	src/config.h	/^    char *log_path;$/;"	m	struct:server_conf_t	access:public
server_conf_t::logfile	src/config.h	/^    char *logfile;$/;"	m	struct:server_conf_t	access:public
server_conf_t::logfp	src/config.h	/^    FILE *logfp;$/;"	m	struct:server_conf_t	access:public
server_conf_t::loglevel	src/config.h	/^    int loglevel;$/;"	m	struct:server_conf_t	access:public
server_conf_t::mode	src/config.h	/^    char mode;$/;"	m	struct:server_conf_t	access:public
server_conf_t::modules	src/config.h	/^    hash_table *modules;$/;"	m	struct:server_conf_t	access:public
server_conf_t::pidfile	src/config.h	/^    char *pidfile;$/;"	m	struct:server_conf_t	access:public
server_conf_t::pipe_fd	src/config.h	/^    int pipe_fd[2];$/;"	m	struct:server_conf_t	access:public
server_conf_t::port	src/config.h	/^    char *port;$/;"	m	struct:server_conf_t	access:public
server_conf_t::process_num	src/config.h	/^    int process_num;$/;"	m	struct:server_conf_t	access:public
server_conf_t::sockfd	src/config.h	/^    int sockfd;$/;"	m	struct:server_conf_t	access:public
server_conf_t::timeout	src/config.h	/^    int timeout;$/;"	m	struct:server_conf_t	access:public
server_conf_t::topics	src/config.h	/^    list *topics;$/;"	m	struct:server_conf_t	access:public
server_conf_t::url	src/config.h	/^    char *url;$/;"	m	struct:server_conf_t	access:public
server_conf_t::verbose	src/config.h	/^    int verbose;$/;"	m	struct:server_conf_t	access:public
server_config	src/main.c	/^server_conf_t server_config;$/;"	v
shutdown	src/main.c	/^static void shutdown(){$/;"	f	file:
sig_usr1	src/main.c	/^static void sig_usr1 (int sig) {$/;"	f	file:	signature:(int sig)
size	src/hash.h	/^    int size;$/;"	m	struct:__anon4	access:public
size	src/hash.h	/^    int size;$/;"	m	struct:__anon8	access:public
skip	src/cJSON.c	/^static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}$/;"	f	file:	signature:(const char *in)
sockfd	src/config.h	/^    int sockfd;$/;"	m	struct:server_conf_t	access:public
stats_cb	src/main.c	/^static int stats_cb(rd_kafka_t *rk, char *json,size_t json_len ,void *opaque){$/;"	f	file:	signature:(rd_kafka_t *rk, char *json,size_t json_len ,void *opaque)
stop	src/main.c	/^static void stop(int sig){$/;"	f	file:	signature:(int sig)
string	src/cJSON.h	/^	char *string;				\/* The item's name string, if this item is the child of, or is in the list of subitems of an object. *\/$/;"	m	struct:cJSON	access:public
suffix_object	src/cJSON.c	/^static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}$/;"	f	file:	signature:(cJSON *prev,cJSON *item)
tail	src/list.h	/^    list_node *tail;$/;"	m	struct:list	access:public
timeout	src/config.h	/^    int timeout;$/;"	m	struct:server_conf_t	access:public
topics	src/config.h	/^    list *topics;$/;"	m	struct:server_conf_t	access:public
type	src/cJSON.h	/^	int type;					\/* The type of the item, as above. *\/$/;"	m	struct:cJSON	access:public
update	src/cJSON.c	/^static int update(printbuffer *p)$/;"	f	file:	signature:(printbuffer *p)
update_zmalloc_stat_add	src/zmalloc.c	71;"	d	file:
update_zmalloc_stat_add	src/zmalloc.c	74;"	d	file:
update_zmalloc_stat_add	src/zmalloc.c	77;"	d	file:
update_zmalloc_stat_alloc	src/zmalloc.c	91;"	d	file:
update_zmalloc_stat_free	src/zmalloc.c	101;"	d	file:
update_zmalloc_stat_sub	src/zmalloc.c	72;"	d	file:
update_zmalloc_stat_sub	src/zmalloc.c	75;"	d	file:
update_zmalloc_stat_sub	src/zmalloc.c	83;"	d	file:
uri	src/config.h	/^    char *uri;$/;"	m	struct:__anon2	access:public
uri	src/config.h	/^    char *uri;$/;"	m	struct:__anon6	access:public
url	src/config.h	/^    char *url;$/;"	m	struct:server_conf_t	access:public
usage	src/main.c	/^static void usage(){$/;"	f	file:
used_memory	src/zmalloc.c	/^static size_t used_memory = 0;$/;"	v	file:
used_memory_mutex	src/zmalloc.c	/^pthread_mutex_t used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
value	src/list.h	/^    void *value;$/;"	m	struct:list_node	access:public
valuedouble	src/cJSON.h	/^	double valuedouble;			\/* The item's number, if type==cJSON_Number *\/$/;"	m	struct:cJSON	access:public
valueint	src/cJSON.h	/^	int valueint;				\/* The item's number, if type==cJSON_Number *\/$/;"	m	struct:cJSON	access:public
valuestring	src/cJSON.h	/^	char *valuestring;			\/* The item's string, if type==cJSON_String *\/$/;"	m	struct:cJSON	access:public
verbose	src/config.h	/^    int verbose;$/;"	m	struct:server_conf_t	access:public
wait_eof	src/main.c	/^static int wait_eof = 0;$/;"	v	file:
zcalloc	src/zmalloc.c	/^void *zcalloc(size_t size) {$/;"	f	signature:(size_t size)
zfree	src/zmalloc.c	/^void zfree(void *ptr) {$/;"	f	signature:(void *ptr)
zlibc_free	src/zmalloc.c	/^void zlibc_free(void *ptr) {$/;"	f	signature:(void *ptr)
zmalloc	src/zmalloc.c	/^void *zmalloc(size_t size) {$/;"	f	signature:(size_t size)
zmalloc_default_oom	src/zmalloc.c	/^static void zmalloc_default_oom(size_t size) {$/;"	f	file:	signature:(size_t size)
zmalloc_enable_thread_safeness	src/zmalloc.c	/^void zmalloc_enable_thread_safeness(void) {$/;"	f	signature:(void)
zmalloc_get_fragmentation_ratio	src/zmalloc.c	/^float zmalloc_get_fragmentation_ratio(size_t rss) {$/;"	f	signature:(size_t rss)
zmalloc_get_private_dirty	src/zmalloc.c	/^size_t zmalloc_get_private_dirty(void) {$/;"	f	signature:(void)
zmalloc_get_rss	src/zmalloc.c	/^size_t zmalloc_get_rss(void) {$/;"	f	signature:(void)
zmalloc_get_smap_bytes_by_field	src/zmalloc.c	/^size_t zmalloc_get_smap_bytes_by_field(char *field) {$/;"	f	signature:(char *field)
zmalloc_oom_handler	src/zmalloc.c	/^static void (*zmalloc_oom_handler)(size_t) = zmalloc_default_oom;$/;"	v	file:
zmalloc_set_oom_handler	src/zmalloc.c	/^void zmalloc_set_oom_handler(void (*oom_handler)(size_t)) {$/;"	f	signature:(void (*oom_handler)(size_t))
zmalloc_size	src/zmalloc.c	/^size_t zmalloc_size(void *ptr) {$/;"	f	signature:(void *ptr)
zmalloc_size	src/zmalloc.h	43;"	d
zmalloc_size	src/zmalloc.h	53;"	d
zmalloc_size	src/zmalloc.h	61;"	d
zmalloc_thread_safe	src/zmalloc.c	/^static int zmalloc_thread_safe = 0;$/;"	v	file:
zmalloc_used_memory	src/zmalloc.c	/^size_t zmalloc_used_memory(void) {$/;"	f	signature:(void)
zrealloc	src/zmalloc.c	/^void *zrealloc(void *ptr, size_t size) {$/;"	f	signature:(void *ptr, size_t size)
zstrdup	src/zmalloc.c	/^char *zstrdup(const char *s) {$/;"	f	signature:(const char *s)
